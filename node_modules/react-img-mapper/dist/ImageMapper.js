"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(require("react"));
var react_fast_compare_1 = __importDefault(require("react-fast-compare"));
var area_1 = require("./helpers/area");
var constants_1 = require("./helpers/constants");
var dimensions_1 = require("./helpers/dimensions");
var draw_1 = __importDefault(require("./helpers/draw"));
var events_1 = require("./helpers/events");
var styles_1 = __importDefault(require("./helpers/styles"));
var ImageMapper = function (_a) {
    var ref = _a.ref, props = __rest(_a, ["ref"]);
    var generatedProps = (0, constants_1.generateProps)(props);
    var src = generatedProps.src, name = generatedProps.name, areas = generatedProps.areas, areaKeyName = generatedProps.areaKeyName, isMulti = generatedProps.isMulti, toggle = generatedProps.toggle, active = generatedProps.active, disabled = generatedProps.disabled, fillColor = generatedProps.fillColor, strokeColor = generatedProps.strokeColor, lineWidth = generatedProps.lineWidth, imgWidth = generatedProps.imgWidth, width = generatedProps.width, height = generatedProps.height, natural = generatedProps.natural, responsive = generatedProps.responsive, parentWidth = generatedProps.parentWidth, containerProps = generatedProps.containerProps, imgProps = generatedProps.imgProps, canvasProps = generatedProps.canvasProps, mapProps = generatedProps.mapProps, areaProps = generatedProps.areaProps, onChange = generatedProps.onChange, onImageClick = generatedProps.onImageClick, onImageMouseMove = generatedProps.onImageMouseMove, onClick = generatedProps.onClick, onMouseDown = generatedProps.onMouseDown, onMouseUp = generatedProps.onMouseUp, onTouchStart = generatedProps.onTouchStart, onTouchEnd = generatedProps.onTouchEnd, onMouseMove = generatedProps.onMouseMove, onMouseEnter = generatedProps.onMouseEnter, onMouseLeave = generatedProps.onMouseLeave, onLoad = generatedProps.onLoad;
    var _b = (0, react_1.useState)(false), isRendered = _b[0], setRendered = _b[1];
    var areasRef = (0, react_1.useRef)(areas);
    var containerRef = (0, react_1.useRef)(null);
    var img = (0, react_1.useRef)(null);
    var canvas = (0, react_1.useRef)(null);
    var ctx = (0, react_1.useRef)(null);
    var interval = (0, react_1.useRef)(0);
    var prevState = (0, react_1.useRef)((function () { return (__assign({ parentWidth: parentWidth }, (0, dimensions_1.getPropDimension)({ width: width, height: height, img: img }))); })());
    var dimensionParams = (0, react_1.useMemo)(function () { return ({ width: width, height: height, responsive: responsive, parentWidth: parentWidth, natural: natural }); }, [width, height, responsive, parentWidth, natural]);
    var scaleCoordsParams = (0, react_1.useMemo)(function () { return ({ width: width, height: height, responsive: responsive, parentWidth: parentWidth, imgWidth: imgWidth }); }, [width, height, responsive, parentWidth, imgWidth]);
    var areaParams = (0, react_1.useMemo)(function () { return ({ fillColor: fillColor, lineWidth: lineWidth, strokeColor: strokeColor }); }, [fillColor, lineWidth, strokeColor]);
    var init = (0, react_1.useCallback)(function () {
        var _a;
        if (((_a = img.current) === null || _a === void 0 ? void 0 : _a.complete) && canvas.current && containerRef.current) {
            ctx.current = canvas.current.getContext('2d');
            setRendered(true);
        }
    }, []);
    (0, react_1.useEffect)(function () {
        if (!isRendered) {
            interval.current = window.setInterval(init, 500);
        }
        else {
            clearInterval(interval.current);
        }
    }, [init, isRendered]);
    var renderPrefilledAreas = (0, react_1.useCallback)(function () {
        areas.forEach(function (area) {
            var extendedArea = (0, area_1.getExtendedArea)(area, __assign({ img: img }, scaleCoordsParams), areaParams);
            if (!extendedArea.preFillColor)
                return false;
            return (0, draw_1.default)(__assign(__assign({}, extendedArea), { fillColor: extendedArea.preFillColor }), ctx);
        });
    }, [areaParams, areas, scaleCoordsParams]);
    var clearCanvas = (0, react_1.useCallback)(function () {
        if (!(ctx.current && canvas.current))
            return;
        ctx.current.clearRect(0, 0, canvas.current.width, canvas.current.height);
    }, []);
    var resetCanvasAndPrefillArea = (0, react_1.useCallback)(function () {
        clearCanvas();
        renderPrefilledAreas();
    }, [clearCanvas, renderPrefilledAreas]);
    var highlightArea = function (area) {
        var extendedArea = (0, area_1.getExtendedArea)(area, __assign({ img: img }, scaleCoordsParams), areaParams);
        if (!extendedArea.active)
            return false;
        return (0, draw_1.default)(extendedArea, ctx);
    };
    var onHighlightArea = function (area) {
        var chosenAreasRef = areasRef.current;
        var chosenArea = isMulti
            ? area
            : chosenAreasRef.find(function (c) { return c[areaKeyName] === area[areaKeyName]; });
        if (!chosenArea)
            return;
        var extendedArea = (0, area_1.getExtendedArea)(chosenArea, __assign({ img: img }, scaleCoordsParams), areaParams);
        if (!(active && extendedArea.active))
            return;
        var chosenAreas = isMulti ? areas : chosenAreasRef;
        var newArea = __assign({}, chosenArea);
        var isCurrentAreaSelected = (function () {
            if (toggle) {
                if (isMulti && newArea.preFillColor)
                    return true;
                return !isMulti && !!area.preFillColor;
            }
            return false;
        })();
        if (isCurrentAreaSelected) {
            var isPreFillColorFromJSON = chosenAreas.find(function (c) { return c[areaKeyName] === area[areaKeyName]; });
            if (isPreFillColorFromJSON === null || isPreFillColorFromJSON === void 0 ? void 0 : isPreFillColorFromJSON.preFillColor)
                delete newArea.preFillColor;
        }
        else {
            newArea.preFillColor = extendedArea.fillColor;
        }
        var updatedAreas = chosenAreas.map(function (cur) {
            return cur[areaKeyName] === area[areaKeyName] ? newArea : cur;
        });
        if (onChange)
            onChange(newArea, updatedAreas);
    };
    var initCanvas = (0, react_1.useCallback)(function (isFirstTime, triggerOnLoad) {
        if (isFirstTime === void 0) { isFirstTime = true; }
        if (triggerOnLoad === void 0) { triggerOnLoad = false; }
        var _a = (0, dimensions_1.getDimensions)(__assign({ img: img }, dimensionParams)), imageWidth = _a.width, imageHeight = _a.height;
        if (!(img.current && canvas.current && containerRef.current && ctx.current))
            return;
        containerRef.current.style.width = "".concat(imageWidth, "px");
        containerRef.current.style.height = "".concat(imageHeight, "px");
        if (isFirstTime) {
            initCanvas(false, true);
        }
        else {
            img.current.width = imageWidth;
            img.current.height = imageHeight;
            canvas.current.width = imageWidth;
            canvas.current.height = imageHeight;
            renderPrefilledAreas();
        }
        if (onLoad && triggerOnLoad) {
            onLoad(img.current, { width: imageWidth, height: imageHeight });
        }
    }, [dimensionParams, onLoad, renderPrefilledAreas]);
    var getRefs = (0, react_1.useCallback)(function () { return ({ containerRef: containerRef.current, imgRef: img.current, canvasRef: canvas.current }); }, []);
    (0, react_1.useEffect)(function () {
        if (isRendered)
            initCanvas();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isRendered]);
    (0, react_1.useEffect)(function () {
        resetCanvasAndPrefillArea();
    }, [areas, resetCanvasAndPrefillArea]);
    (0, react_1.useEffect)(function () {
        if (responsive && parentWidth && prevState.current.parentWidth !== parentWidth) {
            initCanvas();
            prevState.current.parentWidth = parentWidth;
        }
        if (width && prevState.current.width !== width) {
            initCanvas();
            prevState.current.width = (0, dimensions_1.getDimension)(width, img);
        }
        if (height && prevState.current.height !== height) {
            initCanvas();
            prevState.current.height = (0, dimensions_1.getDimension)(height, img);
        }
    }, [height, initCanvas, parentWidth, responsive, width]);
    (0, react_1.useImperativeHandle)(ref, function () { return ({ getRefs: getRefs }); }, [getRefs]);
    var handleMouseEnter = function (area) {
        if (active)
            highlightArea(area);
    };
    var handleMouseLeave = function () {
        if (active)
            resetCanvasAndPrefillArea();
    };
    var handleClick = function (area) {
        onHighlightArea(area);
    };
    var renderAreas = function () {
        return areas.map(function (area, index) {
            var _a;
            var scaledCoords = (0, area_1.getExtendedArea)(area, __assign({ img: img }, scaleCoordsParams), areaParams).scaledCoords;
            if (area.disabled)
                return null;
            var preFillColor = area.preFillColor, shape = area.shape, href = area.href;
            return (react_1.default.createElement("area", __assign({ alt: "map" }, areaProps, { className: __spreadArray(__spreadArray([
                    'img-mapper-area'
                ], (preFillColor ? ['img-mapper-area-highlighted'] : []), true), ((areaProps === null || areaProps === void 0 ? void 0 : areaProps.className) ? [areaProps.className] : []), true).join(' '), key: (_a = area[areaKeyName]) !== null && _a !== void 0 ? _a : index.toString(), href: href !== null && href !== void 0 ? href : areaProps === null || areaProps === void 0 ? void 0 : areaProps.href, shape: shape !== null && shape !== void 0 ? shape : areaProps === null || areaProps === void 0 ? void 0 : areaProps.shape, coords: scaledCoords.join(','), onMouseEnter: (0, events_1.mouseEnter)({ area: area, index: index }, { onMouseEnter: onMouseEnter, cb: handleMouseEnter }), onMouseLeave: (0, events_1.mouseLeave)({ area: area, index: index }, { onMouseLeave: onMouseLeave, cb: handleMouseLeave }), onMouseMove: (0, events_1.mouseMove)({ area: area, index: index }, { onMouseMove: onMouseMove }), onMouseDown: (0, events_1.mouseDown)({ area: area, index: index }, { onMouseDown: onMouseDown }), onMouseUp: (0, events_1.mouseUp)({ area: area, index: index }, { onMouseUp: onMouseUp }), onTouchStart: (0, events_1.touchStart)({ area: area, index: index }, { onTouchStart: onTouchStart }), onTouchEnd: (0, events_1.touchEnd)({ area: area, index: index }, { onTouchEnd: onTouchEnd }), onClick: (0, events_1.click)({ area: area, index: index }, { onClick: onClick, cb: handleClick }) })));
        });
    };
    return (react_1.default.createElement("div", __assign({}, containerProps, { ref: containerRef, id: "img-mapper", style: __assign(__assign({}, containerProps === null || containerProps === void 0 ? void 0 : containerProps.style), styles_1.default.container) }),
        react_1.default.createElement("img", __assign({ role: "presentation", alt: "map" }, imgProps, { ref: img, src: src, useMap: "#".concat(name), className: __spreadArray(['img-mapper-img'], ((imgProps === null || imgProps === void 0 ? void 0 : imgProps.className) ? [imgProps.className] : []), true).join(' '), style: __assign(__assign(__assign({}, imgProps === null || imgProps === void 0 ? void 0 : imgProps.style), styles_1.default.img(responsive)), (!isRendered ? { display: 'none' } : null)), onClick: (0, events_1.imageClick)({ onImageClick: onImageClick }), onMouseMove: (0, events_1.imageMouseMove)({ onImageMouseMove: onImageMouseMove }) })),
        react_1.default.createElement("canvas", __assign({}, canvasProps, { ref: canvas, className: __spreadArray([
                'img-mapper-canvas'
            ], ((canvasProps === null || canvasProps === void 0 ? void 0 : canvasProps.className) ? [canvasProps.className] : []), true).join(' '), style: __assign(__assign({}, canvasProps === null || canvasProps === void 0 ? void 0 : canvasProps.style), styles_1.default.canvas) })),
        react_1.default.createElement("map", __assign({}, mapProps, { className: __spreadArray(['img-mapper-map'], ((mapProps === null || mapProps === void 0 ? void 0 : mapProps.className) ? [mapProps.className] : []), true).join(' '), name: name, style: __assign(__assign({}, mapProps === null || mapProps === void 0 ? void 0 : mapProps.style), styles_1.default.map(onClick)) }), isRendered && !disabled && renderAreas())));
};
exports.default = (0, react_1.memo)(ImageMapper, function (prevProps, nextProps) {
    var propChanged = constants_1.rerenderPropsList.some(function (prop) { return prevProps[prop] !== nextProps[prop]; });
    return (0, react_fast_compare_1.default)(prevProps.areas, nextProps.areas) && !propChanged;
});
